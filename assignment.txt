NAME: OJO TEMITOPE ESTHER
MATRIC NUMBER:230502042
COURSE TITLE: CSC-309

             ASSIGNMENT 2

ACTIVITY 1

1. Trace how linked list insertion at the head works using a diagram.

Assume the linked list already contains the values:

10 → 20 → 30

The HEAD is pointing to the first node (10).

1. Before insertion

HEAD → 10 → 20 → 30 → NULL


2. Create a new node with value 5

Right now it's not connected to the list:

New node: 5 → NULL


3. Make the new node point to the old head

We connect the new node’s pointer to the current head (10):

5 → 10 → 20 → 30 → NULL


4. Move HEAD to the new node

Now the head of the list becomes 5:

HEAD → 5 → 10 → 20 → 30 → NULL

1. Difference between arrays and linked lists

Arrays                                                                              	Linked Lists

Stored in continuous (fixed) memory	                       Stored in scattered memory
Fixed size	                                                                  Grow and shrink easily
Fast random access (A[i])	                                      Sequential access only
Expensive insertion/deletion (shift needed)	          Easy insertion/deletion




2. Time complexity of insertion in a linked list

At beginning: O(1)

At end: O(n) (unless tail pointer exists)

At a given position: O(n) (must traverse)



                ACTIVITY 2

1. Key differences between primitive data types and ADTs

Primitive types are basic built-in types (int, float, char).

ADTs (Abstract Data Types) are user-defined structures like Stack, Queue, LinkedList with defined operations.




2. Why arrays are static and linked lists dynamic

Arrays have fixed size decided at creation → static.

Linked lists grow and shrink using dynamically allocated nodes → dynamic.





3. When to prefer a linked list over an array

Use a linked list when:

You expect many insertions or deletions.

You don’t know the size in advance.

Memory needs to be allocated on demand.




4. Real-world examples

Stack (LIFO)

Undo/Redo operations in apps

Browser back button

Storing function calls (call stack)


Queue (FIFO)

Printing tasks (print queue)

Customer service lines

Task scheduling


Linked List

Music playlist where you skip next/previous

Photo slideshow

Navigation systems (linked routes)



PART 2

- Program to find the sum of the first 10 natural numbers

Solution

The first 10 natural numbers are:
1, 2, 3, 4, 5, 6, 7, 8, 9, 10

Program 

sum = 0
for i in range(1, 11):
    sum = sum + i
print(sum)

Answer

Sum = 55


- Program to generate the Fibonacci series of 8 values using a dynamic array of capacity 2

Procedure

Start with an array of capacity 2

Resize (double capacity) whenever array becomes full

Generate 8 Fibonacci numbers


Fibonacci Series (first 8 terms)

0, 1, 1, 2, 3, 5, 8, 13

Program (pseudocode)

fib = DynamicArray(capacity=2)

a = 0
b = 1
fib.append(a)
fib.append(b)

for i in range(6):
    c = a + b
    fib.append(c)
    a = b
    b = c

Answer

Fibonacci series = 0, 1, 1, 2, 3, 5, 8, 13

- Insert the values 10, 20, 30, 40, 50 into a dynamic array of capacity 2

Insertion Process

Step	Array Contents	                                      Capacity	                       Action

Insert 10	[10].                             	                               2                      Normal insert
Insert 20	[10, 20]	                                                      2                       Normal insert
Insert 30	[10, 20] → resized to 4 → [10, 20, 30]	4	                 Resize
Insert 40	[10, 20, 30, 40]	                                       4	               Normal insert
Insert 50	Resize to 8 → [10,20,30,40,50]	                8	                Resize


Final Answer

Dynamic Array = [10, 20, 30, 40, 50]

- Perform a linear search on the array:

Array: [2, 5, 7, 10, 4, 20]
Target: 10

Tracing

Check 2 → not found

Check 5 → not found

Check 7 → not found

Check 10 → FOUND at index 3


Answer

10 found at index 3 using linear search


- Trace the binary search on:

Array (sorted): [1, 3, 5, 7, 9, 11, 13]
Target = 9

Tracing Steps

1. low = 0, high = 6
mid = (0+6)//2 = 3 → arr[3] = 7
7 < 9 → search right half


2. low = 4, high = 6
mid = (4+6)//2 = 5 → arr[5] = 11
11 > 9 → search left half


3. low = 4, high = 4
mid = 4 → arr[4] = 9 FOUND



Answer

Binary search found 9 at index 4

- State the time and space complexity of linear and binary search

Linear Search

Time Complexity:

Best case: O(1)

Worst case: O(n)


Space Complexity: O(1)


Binary Search

Time Complexity:

Best case: O(1)

Worst case: O(log n)


Space Complexity: O(1) for iterative version



- Five differences between Stack and Queue

Stack	                                                                Queue

Uses LIFO (Last In First Out).                	Uses FIFO (First In First Out)
Insertion at top	                                        Insertion at rear
Removal from top                                   	Removal from front
Example: function calls	                               Example: printers, scheduling
Main operations: push, pop	                       Main operations: enqueue, dequeue


- Time complexities of stack and queue operations

Stack

Operation	Time Complexity

isFull()	       O(1)
isEmpty()	O(1)
peek()      	O(1)
push()      	O(1)
pop()	        O(1)


Queue

Operation	Time Complexity

isFull()	         O(1)
isEmpty()	O(1)
front()	        O(1)
enqueue()	O(1)
dequeue()	O(1)